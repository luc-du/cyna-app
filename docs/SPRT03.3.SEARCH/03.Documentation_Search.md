# Documentation professionnelle de la fonctionnalité “Recherche”

Cette documentation couvre l’ensemble de la mise en œuvre de la page de recherche avancée, conformément au Cahier des Charges (CDC), en incluant la mise à jour apportée pour la gestion mobile (suppression du modal overlay et redirection vers `/search`). Elle décrit en détail la structure, les slices Redux, les composants React, l’accessibilité et les bonnes pratiques.

---

## Table des matières

- [Documentation professionnelle de la fonctionnalité “Recherche”](#documentation-professionnelle-de-la-fonctionnalité-recherche)
  - [Table des matières](#table-des-matières)
  - [Introduction](#introduction)
  - [Architecture générale](#architecture-générale)
  - [Arborescence des fichiers](#arborescence-des-fichiers)
  - [Slice Redux : `searchSlice.js`](#slice-redux--searchslicejs)
    - [Explications](#explications)
  - [Slice Redux : `categorySlice.js`](#slice-redux--categoryslicejs)
    - [Explications](#explications-1)
  - [Composants de la page de recherche](#composants-de-la-page-de-recherche)
    - [6.1. `FilterCheckboxes.jsx`](#61-filtercheckboxesjsx)
      - [Fonctionnalité](#fonctionnalité)
    - [6.2. `PriceSlider.jsx`](#62-pricesliderjsx)
      - [Fonctionnalité](#fonctionnalité-1)
    - [6.3. `AvailabilityToggle.jsx`](#63-availabilitytogglejsx)
      - [Fonctionnalité](#fonctionnalité-2)
    - [6.4. `SortSelect.jsx`](#64-sortselectjsx)
      - [Fonctionnalité](#fonctionnalité-3)
    - [6.5. `SearchPage.jsx` et champ in-page](#65-searchpagejsx-et-champ-in-page)
    - [Explications](#explications-2)
  - [Composants utilitaires](#composants-utilitaires)
    - [7.1. `SearchBar.jsx`](#71-searchbarjsx)
      - [Fonctionnement](#fonctionnement)
    - [7.2. `EmptyState.jsx`](#72-emptystatejsx)
      - [Fonctionnalité](#fonctionnalité-4)
    - [7.3. `Loader.jsx`](#73-loaderjsx)
      - [Fonctionnalité](#fonctionnalité-5)
  - [Composant `Navbar.jsx` et adaptation mobile](#composant-navbarjsx-et-adaptation-mobile)
    - [Explications](#explications-3)
  - [Configuration du routeur](#configuration-du-routeur)
  - [Étapes d’installation et de test](#étapes-dinstallation-et-de-test)
  - [Explications détaillées et flux utilisateur](#explications-détaillées-et-flux-utilisateur)
  - [Accessibilité et bonnes pratiques](#accessibilité-et-bonnes-pratiques)
  - [Mise à jour mobile : suppression du modal overlay (cf. update table)](#mise-à-jour-mobile--suppression-du-modal-overlay-cf-update-table)
    - [Ancien comportement](#ancien-comportement)
    - [Nouveau comportement (cf. §8)](#nouveau-comportement-cf-8)
  - [Conclusion](#conclusion)

---

## Introduction

La fonctionnalité **“Recherche”** répond aux exigences suivantes du Cahier des Charges :

- Permettre à l’utilisateur d’effectuer une recherche textuelle de produits ou services en temps réel.
- Proposer des facettes (catégories, caractéristiques techniques, intervalle de prix, disponibilité).
- Offrir un tri dynamique (prix croissant/décroissant, nouveauté, disponibilité).
- Garantir la performance (résultats < 100 ms en frontend, lazy loading possible).
- Fournir un fallback mock filtré si le backend est indisponible.
- Afficher des messages francisés (chargement, erreur, “aucun résultat”).
- Assurer l’accessibilité (ARIA, gestion du focus, contraste).

Cette documentation décrit :

- La structure globale du projet.
- Les slices Redux pour la recherche et les catégories.
- Les composants de filtre et la page `SearchPage.jsx`.
- Les utilitaires d’interface (`SearchBar`, `EmptyState`, `Loader`).
- La navbar et l’adaptation mobile (voir la mise à jour mobile : suppression du modal overlay, §13).
- La configuration du routeur.
- Les étapes d’installation et de test.
- Les bonnes pratiques d’accessibilité.

---

## Architecture générale

1. **Store Redux** regroupe deux slices principales :

   - `searchSlice.js` : gère la recherche (mot-clé, résultats, état de chargement, erreurs, pagination, facettes, tri).
   - `categorySlice.js` : récupère la liste des catégories (API + fallback mock).

2. **Composants React** :

   - Composants de filtres : `FilterCheckboxes`, `PriceSlider`, `AvailabilityToggle`, `SortSelect`.
   - Page de recherche : `SearchPage.jsx`, qui assemble :

     - Le champ de recherche in-page (focus automatique).
     - Le titre et le bouton de réinitialisation.
     - Le tri dynamique.
     - La grille de résultats ou les messages (loader, erreur, empty state).

   - **Utilitaires d’interface** : `SearchBar.jsx` (barre de recherche dans la navbar), `EmptyState.jsx`, `Loader.jsx`.

3. **Navbar** :

   - Intègre la `SearchBar` pour desktop.
   - Pour mobile, le bouton loupe redirige directement vers `/search` (suppression du modal overlay, cf. §13).
   - Intègre un menu burger mobile via `MobileMenu`.

4. **Routeur principal** (dans `App.jsx`) déclare la route `/search`, ainsi que les routes principales (`/`, `/products/:id`, etc.).

5. **Mock Data** (`MOCK_TOP_PRODUCTS`, `MOCK_CATEGORIES`, etc.) : situés dans `src/mock/MOCKS_DATA.jsx`, utilisés pour le fallback en cas d’erreur serveur.

L’objectif est d’offrir une **expérience homogène** desktop/mobile, tout en respectant les recommandations d’accessibilité et de performance.

---

## Arborescence des fichiers

```text
src/
├─ api/
│  └─ apiRoutes.js
├─ components/
│  ├─ Home/
│  │  └─ ProductCard.jsx
│  ├─ Navbar/
│  │  ├─ Navbar.jsx
│  │  ├─ CartBadge.jsx
│  │  ├─ MobileMenu.jsx
│  │  └─ NavbarLinks.jsx
│  ├─ Search/
│  │  ├─ FilterCheckboxes.jsx
│  │  ├─ PriceSlider.jsx
│  │  ├─ AvailabilityToggle.jsx
│  │  ├─ SortSelect.jsx
│  │  └─ SearchBar.jsx
│  └─ ui/
│     ├─ EmptyState.jsx
│     └─ Loader.jsx
├─ mock/
│  └─ MOCKS_DATA.jsx
├─ pages/
│  ├─ HomePage.jsx
│  ├─ ProductPage.jsx
│  └─ SearchPage.jsx
├─ redux/
│  ├─ slice/
│  │  ├─ searchSlice.js
│  │  └─ categorySlice.js
│  └─ store.js
└─ App.jsx
```

- **`api/apiRoutes.js`** : définit les routes de l’API (authentification, catégories, produits, etc.).
- **`components/Home/ProductCard.jsx`** : composant qui affiche un produit (image, nom, prix, promotion, badge, etc.).
- **`components/Navbar`** : regroupe `Navbar.jsx`, `CartBadge.jsx`, `MobileMenu.jsx`, `NavbarLinks.jsx` et la logique du bouton loupe mobile (§13).
- **`components/Search`** : contient les composants de la page de recherche, y compris le champ in-page (`SearchPage`) et la `SearchBar` (navbar).
- **`components/ui`** : composants génériques (`EmptyState`, `Loader`).
- **`mock/MOCKS_DATA.jsx`** : données simulées pour le fallback (top products, categories).
- **`pages/SearchPage.jsx`** : page dédiée à la recherche avancée.
- **`redux/slice`** : contient `searchSlice.js` (logique de recherche) et `categorySlice.js` (récupération des catégories).
- **`redux/store.js`** : configuration du store Redux.
- **`App.jsx`** : routeur principal, intégration de `Navbar` et `Footer`.

---

## Slice Redux : `searchSlice.js`

**Chemin** : `src/redux/slice/searchSlice.js`

```js
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import axios from "axios";
import { API_ROUTES } from "../../api/apiRoutes";
import { MOCK_TOP_PRODUCTS } from "../../mock/MOCKS_DATA";

/**
 * Async thunk pour rechercher des produits :
 * - Paramètres : { keyword, page, size, categoriesIds, features, minPrice, maxPrice, availableOnly, sort }.
 * - Si l’API renvoie [] → retourne [] (fulfilled).
 * - En cas d’erreur réseau → applique un fallback local (MOCK_TOP_PRODUCTS filtré).
 */
export const searchProducts = createAsyncThunk(
  "search/searchProducts",
  async (
    {
      keyword = "",
      page = 0,
      size = 6,
      categoriesIds = [],
      features = [],
      minPrice = 0,
      maxPrice = 100000,
      availableOnly = false,
      sort = "priceAsc",
    },
    { rejectWithValue }
  ) => {
    try {
      // Construction dynamique des query params
      const queryParams = new URLSearchParams();
      if (keyword) queryParams.set("keyword", keyword);
      queryParams.set("page", page);
      queryParams.set("size", size);
      if (categoriesIds.length) {
        categoriesIds.forEach((id) => queryParams.append("categoriesIds", id));
      }
      if (features.length) {
        features.forEach((f) => queryParams.append("features", f));
      }
      if (minPrice !== undefined) queryParams.set("minPrice", minPrice);
      if (maxPrice !== undefined) queryParams.set("maxPrice", maxPrice);
      if (availableOnly) queryParams.set("availableOnly", true);
      if (sort) queryParams.set("sort", sort);

      // Appel à l’API (concat queryParams à l’URL de API_ROUTES)
      const url =
        API_ROUTES.PRODUCTS.SEARCH({ keyword, page, size }) +
        `&${queryParams.toString()}`;
      const response = await axios.get(url);
      const data = response.data;

      // Si pas de résultat retourné par l’API
      if (
        !data ||
        !Array.isArray(data.products) ||
        data.products.length === 0
      ) {
        return [];
      }

      return data.products;
    } catch (err) {
      // Récupération du message d’erreur (ou message générique)
      const msg =
        err.response?.data?.message || "Erreur serveur lors de la recherche";

      // Filtrer MOCK_TOP_PRODUCTS localement sur les mêmes critères
      const filteredMock = MOCK_TOP_PRODUCTS.filter((product) => {
        // Haystack = nom + description + caractéristiques (toutes en minuscules)
        const haystack = `${product.name} ${product.description || ""} ${
          product.caracteristics || ""
        }`.toLowerCase();

        // 1) Correspondance du mot-clé
        if (keyword && !haystack.includes(keyword.toLowerCase())) {
          return false;
        }

        // 2) Correspondance catégories
        if (
          categoriesIds.length &&
          !product.categoriesIds?.some((id) => categoriesIds.includes(id))
        ) {
          return false;
        }

        // 3) Correspondance features
        if (
          features.length &&
          !features.every((f) =>
            (product.caracteristics || "")
              .toLowerCase()
              .includes(f.toLowerCase())
          )
        ) {
          return false;
        }

        // 4) Intervalle du prix
        if (product.amount < minPrice || product.amount > maxPrice) {
          return false;
        }

        // 5) Disponibilité
        if (availableOnly && !product.available) {
          return false;
        }

        return true;
      });

      return rejectWithValue({
        isFallback: true,
        fallback: filteredMock,
        message: msg,
      });
    }
  }
);

const initialState = {
  query: "",
  searchResults: [],
  loading: false,
  error: null,
  isSearchMode: false,
  currentPage: 0,
  pageSize: 6,
};

const searchSlice = createSlice({
  name: "search",
  initialState,
  reducers: {
    /**
     * Met à jour la requête (keyword) et bascule en mode recherche.
     */
    setQuery: (state, action) => {
      state.query = action.payload;
      state.isSearchMode = true;
    },
    /**
     * Réinitialise entièrement la recherche (query, résultats, erreur, mode, page).
     */
    clearSearch: (state) => {
      state.query = "";
      state.searchResults = [];
      state.error = null;
      state.isSearchMode = false;
      state.currentPage = 0;
    },
  },
  extraReducers: (builder) => {
    builder
      // Pending : début de la recherche → loading = true, error = null
      .addCase(searchProducts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      // Fulfilled : recherche réussie → loading = false, résultats mis à jour, error = null
      .addCase(searchProducts.fulfilled, (state, action) => {
        state.loading = false;
        state.searchResults = action.payload;
        state.error = null;
      })
      // Rejected : backend indisponible ou erreur → loading = false, fallback ou erreur
      .addCase(searchProducts.rejected, (state, action) => {
        state.loading = false;
        const payload = action.payload || {};
        if (payload.isFallback) {
          state.searchResults = payload.fallback;
          state.error = payload.message
            ? `Attention : ${payload.message}`
            : "Résultats limités (mode offline).";
        } else {
          state.searchResults = [];
          state.error =
            payload.message || "Erreur inconnue lors de la recherche.";
        }
      });
  },
});

export const { setQuery, clearSearch } = searchSlice.actions;
export default searchSlice.reducer;
```

### Explications

- **Thunks**

  - `searchProducts` prend un objet de paramètres couvrant le mot-clé, la pagination, toutes les facettes (catégories, caractéristiques, prix, disponibilité) et le critère de tri.
  - En cas de réponse vide de l’API, on retourne `[]` (permet d’afficher “Aucun résultat”).
  - En cas d’erreur réseau, un filtrage local est réalisé sur `MOCK_TOP_PRODUCTS` pour ne conserver que les produits correspondant aux mêmes filtres.
  - L’objet renvoyé dans `rejectWithValue` contient :

    - `isFallback: true` (indique qu’on a appliqué le fallback mock).
    - `fallback: filteredMock` (tableau des produits filtrés localement).
    - `message: msg` (message d’erreur serveur ou message générique).

- **State initial**

  - `query` (chaîne vide).
  - `searchResults` (tableau vide).
  - `loading` (booléen).
  - `error` (chaîne ou `null`).
  - `isSearchMode` (booléen).
  - `currentPage` / `pageSize` (pagination par défaut).

- **Reducers**

  - `setQuery` : met à jour `query` et bascule en mode recherche (`isSearchMode = true`).
  - `clearSearch` : remet le store à l’état initial (vide, aucune recherche).

- **ExtraReducers**

  - `pending` : `loading = true`, `error = null`.
  - `fulfilled` : `loading = false`, `searchResults = payload`, `error = null`.
  - `rejected` : `loading = false`,

    - Si `payload.isFallback === true` : `searchResults = payload.fallback`, `error = "Attention : …"`.
    - Sinon : `searchResults = []`, `error = payload.message || "Erreur inconnue …"`.

---

## Slice Redux : `categorySlice.js`

**Chemin** : `src/redux/slice/categorySlice.js`

```js
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import axios from "axios";
import { API_ROUTES } from "../../api/apiRoutes";
import { MOCK_CATEGORIES } from "../../mock/MOCKS_DATA";

/**
 * Async thunk pour récupérer les catégories :
 * - Si l’API renvoie un tableau vide → fallback `MOCK_CATEGORIES`.
 * - En cas d’erreur réseau → fallback `MOCK_CATEGORIES`.
 */
export const fetchCategories = createAsyncThunk(
  "categories/fetchAll",
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get(API_ROUTES.CATEGORIES.ALL);
      const data = response.data;
      if (!Array.isArray(data) || data.length === 0) {
        return rejectWithValue(MOCK_CATEGORIES);
      }
      return data;
    } catch (error) {
      if (error.response?.data?.message) {
        return rejectWithValue(error.response.data.message);
      }
      return rejectWithValue(MOCK_CATEGORIES);
    }
  }
);

const categorySlice = createSlice({
  name: "categories",
  initialState: {
    list: [],
    loading: false,
    error: null,
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchCategories.pending, (state) => {
        state.loading = true;
        state.error = null;
        state.list = [];
      })
      .addCase(fetchCategories.fulfilled, (state, action) => {
        state.loading = false;
        state.list = action.payload;
      })
      .addCase(fetchCategories.rejected, (state, action) => {
        state.loading = false;
        if (Array.isArray(action.payload)) {
          // Fallback mock (tableau)
          state.list = action.payload;
          state.error = "Fallback mock appliqué pour les catégories.";
        } else {
          state.list = [];
          state.error =
            action.payload ||
            "Erreur inconnue lors du chargement des catégories.";
        }
      });
  },
});

export default categorySlice.reducer;
```

### Explications

- **`fetchCategories`**

  - Appel à `API_ROUTES.CATEGORIES.ALL`.
  - Si l’API renvoie un tableau vide ou si erreur réseau : `rejectWithValue(MOCK_CATEGORIES)`.

- **State initial**

  - `list: []`, `loading: false`, `error: null`.

- **ExtraReducers**

  - `pending` : `loading = true`, `error = null`, `list = []`.
  - `fulfilled` : `loading = false`, `list = payload`.
  - `rejected` : `loading = false`,

    - Si `action.payload` est un tableau : `list = MOCK_CATEGORIES`, `error = "Fallback mock appliqué ..."`.
    - Sinon : `list = []`, `error = message || "Erreur inconnue ..."`.

---

## Composants de la page de recherche

Tous les composants suivants se trouvent dans `src/components/Search/`.

### 6.1. `FilterCheckboxes.jsx`

**Chemin** : `src/components/Search/FilterCheckboxes.jsx`

```jsx
import React from "react";
import PropTypes from "prop-types";

/**
 * Affiche une liste de cases à cocher pour sélectionner plusieurs options.
 *
 * Props :
 * - title : libellé de la section (ex. “Catégories”).
 * - options : tableau d’objets { id, name }.
 * - selected : tableau d’IDs actuellement cochés.
 * - onChange : callback (Array<ID>) => void, appelé avec le nouveau tableau d’IDs.
 */
export default function FilterCheckboxes({
  title,
  options,
  selected,
  onChange,
}) {
  const handleToggle = (optionId) => {
    if (selected.includes(optionId)) {
      onChange(selected.filter((id) => id !== optionId));
    } else {
      onChange([...selected, optionId]);
    }
  };

  return (
    <div className="mb-6">
      <h4 className="font-medium mb-2">{title}</h4>
      <div className="flex flex-col space-y-1">
        {options.map((opt) => (
          <label key={opt.id} className="inline-flex items-center space-x-2">
            <input
              type="checkbox"
              value={opt.id}
              checked={selected.includes(opt.id)}
              onChange={() => handleToggle(opt.id)}
              className="form-checkbox h-4 w-4 text-primary focus:ring-2 focus:ring-primary"
            />
            <span className="text-gray-700">{opt.name}</span>
          </label>
        ))}
      </div>
    </div>
  );
}

FilterCheckboxes.propTypes = {
  title: PropTypes.string.isRequired,
  options: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
      name: PropTypes.string.isRequired,
    })
  ).isRequired,
  selected: PropTypes.arrayOf(
    PropTypes.oneOfType([PropTypes.string, PropTypes.number])
  ).isRequired,
  onChange: PropTypes.func.isRequired,
};
```

#### Fonctionnalité

- Affiche un titre `<h4>` et une liste verticale de cases à cocher.
- Gère l’ajout/suppression d’IDs dans le tableau `selected`.
- Appelle `onChange(newSelectedArray)` après chaque modification.

### 6.2. `PriceSlider.jsx`

**Chemin** : `src/components/Search/PriceSlider.jsx`

```jsx
import React from "react";
import PropTypes from "prop-types";

/**
 * Permet de sélectionner un prix minimum et un prix maximum.
 * Implémentation simple : deux inputs `number`.
 *
 * Props :
 * - label : intitulé (ex. “Prix (min / max)”).
 * - min : valeur minimale (ex. 0).
 * - max : valeur maximale (ex. 2000).
 * - value : [prixMinActuel, prixMaxActuel].
 * - onChange : callback ({ min: number, max: number }) => void.
 */
export default function PriceSlider({ label, min, max, value, onChange }) {
  const [currentMin, currentMax] = value;

  const handleMinChange = (e) => {
    const newMin = Number(e.target.value);
    if (newMin >= min && newMin <= currentMax && newMin <= max) {
      onChange({ min: newMin, max: currentMax });
    }
  };

  const handleMaxChange = (e) => {
    const newMax = Number(e.target.value);
    if (newMax <= max && newMax >= currentMin && newMax >= min) {
      onChange({ min: currentMin, max: newMax });
    }
  };

  return (
    <div className="mb-6">
      <label className="block font-medium mb-2">{label}</label>
      <div className="flex items-center space-x-2">
        <input
          type="number"
          aria-label="Prix minimum"
          value={currentMin}
          onChange={handleMinChange}
          className="w-20 px-2 py-1 border rounded-md text-black focus:outline-none focus:ring-2 focus:ring-primary"
          min={min}
          max={max}
        />
        <span className="text-gray-600">–</span>
        <input
          type="number"
          aria-label="Prix maximum"
          value={currentMax}
          onChange={handleMaxChange}
          className="w-20 px-2 py-1 border rounded-md text-black focus:outline-none focus:ring-2 focus:ring-primary"
          min={min}
          max={max}
        />
      </div>
    </div>
  );
}

PriceSlider.propTypes = {
  label: PropTypes.string.isRequired,
  min: PropTypes.number.isRequired,
  max: PropTypes.number.isRequired,
  value: PropTypes.arrayOf(PropTypes.number).isRequired,
  onChange: PropTypes.func.isRequired,
};
```

#### Fonctionnalité

- Deux champs `<input type="number" />` pour saisir le prix minimum et le prix maximum.
- Valide que `min ≤ max` et que les valeurs restent dans les bornes.
- Appelle `onChange({ min, max })` lorsque l’un des champs change.

### 6.3. `AvailabilityToggle.jsx`

**Chemin** : `src/components/Search/AvailabilityToggle.jsx`

```jsx
import React from "react";
import PropTypes from "prop-types";

/**
 * Checkbox pour filtrer sur la disponibilité des services.
 *
 * Props :
 * - label : texte à afficher (ex. “Services disponibles uniquement”).
 * - checked : booléen (true = filtrer sur “disponible”).
 * - onChange : callback (newChecked: boolean) => void.
 */
export default function AvailabilityToggle({ label, checked, onChange }) {
  return (
    <div className="mb-6">
      <label className="inline-flex items-center space-x-2">
        <input
          type="checkbox"
          checked={checked}
          onChange={(e) => onChange(e.target.checked)}
          className="form-checkbox h-4 w-4 text-primary focus:ring-2 focus:ring-primary"
        />
        <span className="text-gray-700">{label}</span>
      </label>
    </div>
  );
}

AvailabilityToggle.propTypes = {
  label: PropTypes.string.isRequired,
  checked: PropTypes.bool.isRequired,
  onChange: PropTypes.func.isRequired,
};
```

#### Fonctionnalité

- Présente une seule case à cocher.
- Permet de filtrer uniquement les services disponibles si cochée.
- Appelle `onChange(newChecked)` lors du changement d’état.

### 6.4. `SortSelect.jsx`

**Chemin** : `src/components/Search/SortSelect.jsx`

```jsx
import React from "react";
import PropTypes from "prop-types";

/**
 * Dropdown pour sélectionner le critère de tri.
 *
 * Props :
 * - sort : valeur actuelle du tri (“priceAsc”, “priceDesc”, “newest”, “oldest”, “availableFirst”).
 * - onChange : callback (newSort: string) => void.
 */
export default function SortSelect({ sort, onChange }) {
  return (
    <div className="inline-flex items-center space-x-2">
      <label htmlFor="sort-select" className="text-gray-600">
        Trier par :
      </label>
      <select
        id="sort-select"
        value={sort}
        onChange={(e) => onChange(e.target.value)}
        className="px-2 py-1 border rounded-md bg-white text-black focus:outline-none focus:ring-2 focus:ring-primary"
      >
        <option value="priceAsc">Prix : du moins cher au plus cher</option>
        <option value="priceDesc">Prix : du plus cher au moins cher</option>
        <option value="newest">Nouveauté : plus récents d’abord</option>
        <option value="oldest">Nouveauté : plus anciens d’abord</option>
        <option value="availableFirst">
          Disponibilité : disponibles d’abord
        </option>
      </select>
    </div>
  );
}

SortSelect.propTypes = {
  sort: PropTypes.oneOf([
    "priceAsc",
    "priceDesc",
    "newest",
    "oldest",
    "availableFirst",
  ]).isRequired,
  onChange: PropTypes.func.isRequired,
};
```

#### Fonctionnalité

- Propose un `<select>` pour changer l’ordre d’affichage des résultats.

- Options disponibles :

  1. `priceAsc` : prix croissant.
  2. `priceDesc` : prix décroissant.
  3. `newest` : nouveautés (produits plus récents en premier).
  4. `oldest` : produits plus anciens en premier.
  5. `availableFirst` : services disponibles en tête.

- Ajoute `sort` en paramètre à la requête `searchProducts`.

### 6.5. `SearchPage.jsx` et champ in-page

**Chemin** : `src/pages/SearchPage.jsx`

```jsx
import React, { useState, useEffect, useRef } from "react";
import { useSelector, useDispatch } from "react-redux";
import {
  setQuery,
  searchProducts,
  clearSearch,
} from "../redux/slice/searchSlice";
import { fetchCategories } from "../redux/slice/categorySlice";

import ProductCard from "../components/Home/ProductCard";
import EmptyState from "../components/ui/EmptyState";
import Loader from "../components/ui/Loader";

import FilterCheckboxes from "../components/Search/FilterCheckboxes";
import PriceSlider from "../components/Search/PriceSlider";
import AvailabilityToggle from "../components/Search/AvailabilityToggle";
import SortSelect from "../components/Search/SortSelect";

/**
 * Page de recherche avancée :
 * - Champ de recherche in-page (focus automatique).
 * - Titre (« Recherche » ou « Résultats pour : ‹ keyword › »).
 * - Bouton Réinitialiser la recherche.
 * - Facettes : catégories, caractéristiques, prix, disponibilité.
 * - Tri dynamique.
 * - Affichage du loader / de la bannière d’erreur / de l’empty state / de la grille de produits.
 */
export default function SearchPage() {
  const dispatch = useDispatch();

  // --- State Redux ---
  const { query, searchResults, loading, error, currentPage, pageSize } =
    useSelector((state) => state.search);
  const { list: categoriesList } = useSelector((state) => state.categories);

  // --- State local pour les facettes et le tri ---
  const [selectedCategoriesIds, setSelectedCategoriesIds] = useState([]);
  const [selectedFeatures, setSelectedFeatures] = useState([]);
  const [minPrice, setMinPrice] = useState(0);
  const [maxPrice, setMaxPrice] = useState(1000);
  const [availableOnly, setAvailableOnly] = useState(false);
  const [sort, setSort] = useState("priceAsc");

  // --- State local pour l’input in-page (synchronisé avec query) ---
  const [localInput, setLocalInput] = useState(query);
  const inPageInputRef = useRef(null);

  // Charger les catégories au premier rendu
  useEffect(() => {
    dispatch(fetchCategories());
  }, [dispatch]);

  // Synchroniser localInput lorsque query change (via SearchBar ou bookmark)
  useEffect(() => {
    setLocalInput(query);
  }, [query]);

  // Debounce : lancer la recherche 300 ms après la dernière frappe
  useEffect(() => {
    const timer = setTimeout(() => {
      const trimmed = localInput.trim();

      if (trimmed !== "") {
        // 1) Mettre à jour query dans Redux
        dispatch(setQuery(trimmed));

        // 2) Lancer searchProducts avec tous les filtres + tri
        dispatch(
          searchProducts({
            keyword: trimmed,
            page: currentPage,
            size: pageSize,
            categoriesIds: selectedCategoriesIds,
            features: selectedFeatures,
            minPrice,
            maxPrice,
            availableOnly,
            sort,
          })
        );
      } else {
        // Si l’input devient vide, réinitialiser la recherche
        dispatch(clearSearch());
      }
    }, 300);

    return () => clearTimeout(timer);
  }, [
    localInput,
    dispatch,
    currentPage,
    pageSize,
    selectedCategoriesIds,
    selectedFeatures,
    minPrice,
    maxPrice,
    availableOnly,
    sort,
  ]);

  // Focus automatique sur l’input in-page au chargement
  useEffect(() => {
    if (inPageInputRef.current) {
      inPageInputRef.current.focus();
    }
  }, []);

  // Réinitialiser tout (query, facettes, tri, localInput)
  const handleResetAll = () => {
    dispatch(clearSearch());
    setSelectedCategoriesIds([]);
    setSelectedFeatures([]);
    setMinPrice(0);
    setMaxPrice(1000);
    setAvailableOnly(false);
    setSort("priceAsc");
    setLocalInput("");
  };

  // Si on arrive “à froid” sur /search avec query prérempli (ex. bookmark), relancer la recherche
  useEffect(() => {
    if (query.trim() !== "") {
      dispatch(
        searchProducts({
          keyword: query,
          page: currentPage,
          size: pageSize,
          categoriesIds: selectedCategoriesIds,
          features: selectedFeatures,
          minPrice,
          maxPrice,
          availableOnly,
          sort,
        })
      );
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <main
      className="container mx-auto px-4 lg:px-6 py-8 flex flex-col lg:flex-row"
      aria-labelledby="search-results-heading"
    >
      {/* ==================================================== */}
      {/* Panneau des filtres (colonne gauche sur desktop) */}
      {/* ==================================================== */}
      <aside className="w-full lg:w-1/4 mb-8 lg:mb-0 lg:pr-6">
        <h3 className="text-xl font-semibold mb-4">Filtres</h3>

        {/* Filtre : Catégories */}
        <FilterCheckboxes
          title="Catégories"
          options={categoriesList}
          selected={selectedCategoriesIds}
          onChange={setSelectedCategoriesIds}
        />

        {/* Filtre : Caractéristiques techniques */}
        <FilterCheckboxes
          title="Caractéristiques techniques"
          options={[
            { id: "cloud", name: "Cloud-native" },
            { id: "siem", name: "SIEM" },
            { id: "xdr", name: "XDR" },
            { id: "edr", name: "EDR" },
          ]}
          selected={selectedFeatures}
          onChange={setSelectedFeatures}
        />

        {/* Filtre : Prix (min / max) */}
        <PriceSlider
          label="Prix (min / max)"
          min={0}
          max={2000}
          value={[minPrice, maxPrice]}
          onChange={({ min, max }) => {
            setMinPrice(min);
            setMaxPrice(max);
          }}
        />

        {/* Filtre : Disponibilité */}
        <AvailabilityToggle
          label="Services disponibles uniquement"
          checked={availableOnly}
          onChange={setAvailableOnly}
        />

        {/* Bouton Réinitialiser tous les filtres */}
        <button
          onClick={handleResetAll}
          className="mt-6 text-sm text-primary hover:underline focus:outline-none"
        >
          Réinitialiser tous les filtres
        </button>
      </aside>

      {/* ==================================================== */}
      {/* Contenu principal (colonne droite sur desktop)       */}
      {/* ==================================================== */}
      <section className="w-full lg:w-3/4">
        {/* ------------------------------ */}
        {/* Champ de recherche in-page     */}
        {/* ------------------------------ */}
        <div className="mb-6">
          <input
            type="text"
            ref={inPageInputRef}
            value={localInput}
            onChange={(e) => setLocalInput(e.target.value)}
            placeholder="Rechercher un produit ou service…"
            className="w-full lg:w-3/4 px-4 py-2 border rounded-md bg-white text-black focus:outline-none focus:ring-2 focus:ring-primary"
            aria-label="Rechercher un produit ou service"
          />
        </div>

        {/* ------------------------------------- */}
        {/* Titre + bouton “Réinitialiser” rapide */}
        {/* ------------------------------------- */}
        <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-6">
          <h2
            id="search-results-heading"
            className="text-2xl font-bold text-primary mb-2 sm:mb-0"
            tabIndex={-1}
          >
            {query.trim() === ""
              ? "Recherche"
              : `Résultats pour : « ${query} »`}
          </h2>
          {query.trim() !== "" && (
            <button
              onClick={handleResetAll}
              className="text-sm text-primary hover:underline focus:outline-none ml-0 sm:ml-4"
            >
              Réinitialiser la recherche
            </button>
          )}
        </div>

        {/* ------------------------------ */}
        {/* Affichage selon l’état actuel  */}
        {/* ------------------------------ */}
        {query.trim() === "" ? (
          // Message d’invitation centré quand aucun mot-clé
          <div className="flex items-center justify-center h-40 text-gray-600">
            Tapez un mot-clé (ex. : “EDR”, “SOC Premium”, “XDR”) pour lancer la
            recherche.
          </div>
        ) : loading ? (
          // Loader centré lorsque loading = true
          <div className="flex items-center justify-center h-40">
            <Loader aria-label="Chargement des résultats" />
          </div>
        ) : (
          <>
            {/* Bannière d’erreur / fallback en cas d’error */}
            {error && (
              <div
                className="text-center mb-4 text-yellow-600"
                role="alert"
                aria-live="assertive"
              >
                {error}
              </div>
            )}

            {/* Sélecteur “Trier par” aligné à droite */}
            <div className="flex justify-end mb-4">
              <SortSelect sort={sort} onChange={setSort} />
            </div>

            {/* EmptyState si aucun résultat ET pas d’erreur */}
            {searchResults.length === 0 && !error ? (
              <div className="flex items-center justify-center h-40">
                <EmptyState message="Aucun produit ne correspond à votre recherche." />
              </div>
            ) : (
              // Grille responsive de produits
              <div
                className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6"
                aria-label="Liste des produits"
              >
                {searchResults.map((product) => (
                  <ProductCard key={product.id} product={product} />
                ))}
              </div>
            )}
          </>
        )}
      </section>
    </main>
  );
}
```

### Explications

- **Champ de recherche in-page**

  - Placé en haut de la zone principale, sous le panneau de filtres.
  - Réception automatique du focus au montage (`inPageInputRef.current.focus()`).
  - `localInput` synchronisé avec `query` Redux : permet d’afficher une valeur initiale quand on arrive sur `/search` avec un `query` déjà présent.
  - Debounce de 300 ms : dès que l’utilisateur cesse de taper, on fait :

    - `dispatch(setQuery(trimmed))`
    - `dispatch(searchProducts(...))` avec tous les paramètres (facettes, tri).
    - Si `trimmed === ""`, on appelle `clearSearch()`.

- **Titre + bouton “Réinitialiser la recherche”**

  - Si `query` vide : titre “Recherche”. Sinon : “Résultats pour : « query »”.
  - Le bouton “Réinitialiser la recherche” apparaît uniquement si `query != ""`.
  - Sur mobile, titre et bouton sont empilés (flex-col), sur desktop disposés sur une même ligne (flex-row).

- **Affichage selon l’état**

  1. `query === ""` : message d’invitation centré (“Tapez un mot-clé…”).
  2. `loading === true` : `<Loader />` centré.
  3. Sinon :

     - Si `error` non nul : bannière jaune (role="alert", aria-live="assertive") + affichage des résultats (mock filtré si fallback).
     - `<SortSelect />` aligné à droite (critère de tri).
     - Si `searchResults.length === 0 && error === null` : `<EmptyState message="Aucun produit ne correspond à votre recherche." />`.
     - Sinon : grille responsive (`grid-cols-1 sm:grid-cols-2 lg:grid-cols-3`) affichant les `ProductCard`.

- **Panneau de filtres** (colonne gauche)

  - `FilterCheckboxes` pour catégories et caractéristiques techniques.
  - `PriceSlider` pour le prix min/max.
  - `AvailabilityToggle` pour la disponibilité.
  - Bouton “Réinitialiser tous les filtres” → appelle `handleResetAll()`.

- **Pagination**

  - Les paramètres `currentPage` / `pageSize` sont envoyés à `searchProducts`.
  - Par défaut, page 0 et 6 éléments par page.
  - La pagination en UI (boutons “Suivant” / “Précédent”) n’est pas couverte ici mais peut être ajoutée ultérieurement.

---

## Composants utilitaires

### 7.1. `SearchBar.jsx`

**Chemin** : `src/components/SearchBar.jsx`

```jsx
import { useEffect, useState } from "react";
import { FaTimes } from "react-icons/fa";
import { useDispatch } from "react-redux";
import { useLocation, useNavigate } from "react-router-dom";
import {
  clearSearch,
  searchProducts,
  setQuery,
} from "../redux/slice/searchSlice";

const DEBOUNCE_DELAY = 300;

/**
 * Barre de recherche pour la Navbar (visible uniquement en desktop).
 *
 * - Debounce (300 ms) pour limiter les appels API.
 * - Dispatch setQuery + searchProducts({ keyword, page: 0, size: 6 }).
 * - Redirection vers /search si nécessaire.
 * - Bouton “X” pour effacer la recherche (clearSearch).
 */
export default function SearchBar() {
  const [inputValue, setInputValue] = useState("");
  const dispatch = useDispatch();
  const location = useLocation();
  const navigate = useNavigate();

  // Debounce pour la valeur inputValue
  useEffect(() => {
    const timer = setTimeout(() => {
      const trimmed = inputValue.trim();
      if (trimmed !== "") {
        dispatch(setQuery(trimmed));
        dispatch(searchProducts({ keyword: trimmed, page: 0, size: 6 }));
        if (location.pathname !== "/search") {
          navigate("/search");
        }
      }
      if (trimmed === "") {
        dispatch(clearSearch());
      }
    }, DEBOUNCE_DELAY);

    return () => clearTimeout(timer);
  }, [inputValue, dispatch, navigate, location]);

  // Si on quitte la page /search, vider l’input
  useEffect(() => {
    if (location.pathname !== "/search") {
      setInputValue("");
      dispatch(clearSearch());
    }
  }, [location.pathname, dispatch]);

  // Effacer la recherche en un clic
  const handleClear = () => {
    setInputValue("");
    dispatch(clearSearch());
  };

  return (
    <div className="relative hidden lg:block">
      <input
        type="text"
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        placeholder="Rechercher un produit ou service…"
        className="w-64 px-3 py-1 border rounded-md bg-white text-black focus:outline-none focus:ring-2 focus:ring-primary"
        aria-label="Champ de recherche de produit"
      />
      {inputValue && (
        <button
          onClick={handleClear}
          className="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700 focus:outline-none"
          aria-label="Effacer la recherche"
        >
          <FaTimes />
        </button>
      )}
    </div>
  );
}
```

#### Fonctionnement

- Masqué en mobile (`hidden lg:block`), visible uniquement en desktop.
- Sur chaque modification de `inputValue`, au bout de 300 ms :

  - `dispatch(setQuery(trimmed))`
  - `dispatch(searchProducts({ keyword: trimmed, page: 0, size: 6 }))`
  - Si on n’est pas déjà sur `/search`, `navigate("/search")`.

- Si `inputValue === ""`, on appelle `clearSearch()`.
- Le bouton “X” efface `inputValue` et déclenche `clearSearch()`.

### 7.2. `EmptyState.jsx`

**Chemin** : `src/components/ui/EmptyState.jsx`

```jsx
import React from "react";
import PropTypes from "prop-types";

/**
 * Composant affichant un visuel « vide » et un message personnalisé,
 * lorsque aucun résultat n’est disponible.
 *
 * Props :
 * - message : chaîne à afficher.
 */
export default function EmptyState({ message }) {
  return (
    <div className="flex flex-col items-center justify-center py-12 text-gray-600">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        className="h-16 w-16 mb-4 text-gray-400"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
        aria-hidden="true"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth={2}
          d="M3 3h18v18H3V3z"
        />
      </svg>
      <p>{message}</p>
    </div>
  );
}

EmptyState.propTypes = {
  message: PropTypes.string.isRequired,
};
```

#### Fonctionnalité

- Affiche une icône SVG représentant un carré vide et un paragraphe contenant `message`.
- Utilisé lorsque la recherche ne retourne aucun produit.

### 7.3. `Loader.jsx`

**Chemin** : `src/components/ui/Loader.jsx`

```jsx
import React from "react";
import PropTypes from "prop-types";

/**
 * Composant d’animation de chargement.
 *
 * Props :
 * - aria-label : description pour les lecteurs d’écran (“Chargement des résultats”).
 */
export default function Loader({ "aria-label": ariaLabel }) {
  return (
    <div
      role="status"
      aria-label={ariaLabel}
      className="flex items-center justify-center py-12"
    >
      <svg
        className="animate-spin h-10 w-10 text-primary"
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
      >
        <circle
          className="opacity-25"
          cx="12"
          cy="12"
          r="10"
          stroke="currentColor"
          strokeWidth="4"
        />
        <path
          className="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.4 0 0 5.4 0 12h4z"
        />
      </svg>
    </div>
  );
}

Loader.propTypes = {
  "aria-label": PropTypes.string.isRequired,
};
```

#### Fonctionnalité

- Affiche un cercle en rotation (`animate-spin`).
- `role="status"` et `aria-label` pour l’accessibilité.
- Centré verticalement/horizontalement via `flex items-center justify-center`.

---

## Composant `Navbar.jsx` et adaptation mobile

**Chemin** : `src/components/Navbar/Navbar.jsx`

```jsx
import { FaSearch } from "react-icons/fa";
import { Link, useNavigate } from "react-router-dom";
import logo from "../../assets/logo-cyna-white.svg";
import SearchBar from "../SearchBar";
import CartBadge from "./CartBadge";
import MobileMenu from "./MobileMenu";
import NavbarLinks from "./NavbarLinks";

/**
 * Navbar principale :
 * - Logo (lien vers “/”).
 * - Liens de navigation (Accueil, Mon panier, Catégories, Me connecter).
 * - SearchBar (visible en desktop).
 * - CartBadge.
 * - Bouton loupe mobile : redirige vers /search.
 * - MobileMenu (hamburger).
 *
 * Mise à jour mobile : suppression du modal overlay (cf. §13).
 */
export default function Navbar() {
  const navigate = useNavigate();

  return (
    <header className="bg-primary text-white px-4 py-2 flex items-center justify-between">
      {/* Logo */}
      <Link to="/" aria-label="Accueil Cyna">
        <img src={logo} alt="Logo Cyna" className="w-40 sm:w-40" />
      </Link>

      {/* Desktop : liens + SearchBar */}
      <nav
        className="hidden lg:flex items-center space-x-4"
        aria-label="Navigation principale"
      >
        <NavbarLinks />
        <SearchBar />
      </nav>

      {/* Panier */}
      <div className="flex items-center space-x-4" aria-label="Panier">
        <CartBadge />
      </div>

      {/* Mobile : icône loupe redirige vers /search + MobileMenu */}
      <div className="lg:hidden flex items-center space-x-4">
        <button
          className="text-white text-xl p-2"
          onClick={() => navigate("/search")}
          aria-label="Ouvrir la recherche"
        >
          <FaSearch />
        </button>
        <MobileMenu />
      </div>
    </header>
  );
}
```

### Explications

- **Logo** : `<Link to="/">` avec `aria-label="Accueil Cyna"`.
- **Desktop** (`hidden lg:flex`) :

  - `NavbarLinks` (liens “Accueil”, “Mon panier”, “Catégories”, “Me connecter”).
  - `SearchBar` (champ de recherche Redux).

- **Panier** : `CartBadge` (icône + nombre d’articles).
- **Mobile** (`lg:hidden`) :

  - Bouton loupe (`FaSearch`) : au clic, `navigate("/search")` (redirige vers la page dédiée de recherche).
  - `MobileMenu` (menu burger).

- **Mise à jour mobile (cf. §13)** : suppression du modal overlay et remplacement par une redirection vers `/search`.

---

## Configuration du routeur

**Chemin** : `src/App.jsx`

```jsx
import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import Navbar from "./components/Navbar/Navbar";
import Footer from "./components/Footer";
import HomePage from "./pages/HomePage";
import SearchPage from "./pages/SearchPage";
import ProductPage from "./pages/ProductPage";
// Autres imports si nécessaire

export default function App() {
  return (
    <Router>
      <div className="flex flex-col min-h-screen">
        <Navbar />
        <main className="flex-grow">
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/search" element={<SearchPage />} />
            <Route path="/products/:id" element={<ProductPage />} />
            {/* Autres routes */}
          </Routes>
        </main>
        <Footer />
      </div>
    </Router>
  );
}
```

- La route **`/search`** charge `SearchPage.jsx`.
- Le champ de recherche dans la Navbar (desktop) ou le bouton loupe (mobile) redirige vers `/search`.
- Toute navigation directe vers `/search` affiche la page avec le champ in-page focalisé (cf. §6.5).

---

## Étapes d’installation et de test

1. **Installer les dépendances**

   ```bash
   npm install
   ```

   ou

   ```bash
   yarn install
   ```

2. **Démarrer l’application en mode développement**

   ```bash
   npm start
   ```

   ou

   ```bash
   yarn start
   ```

3. **Tester la fonctionnalité**

   - Accéder à `http://localhost:3000/`.

   - Vérifier la Navbar :

     - En desktop, `SearchBar` est visible.
     - En mobile, le bouton loupe redirige vers `/search`.

   - **Page `/search`** :

     1. Champ de recherche in-page visible et focalisé (bord lumineux).
     2. Message d’invitation (“Tapez un mot-clé …”) si `query` vide.
     3. Taper un mot-clé (“SOC”) → la recherche démarre (300 ms après la dernière frappe).

        - Si backend UP, les résultats se chargent.
        - Si backend DOWN, bannière orange + mock filtré (cf. §4).

     4. Facettes (catégories, caractéristiques, prix, disponibilité) : cocher/décocher met à jour instantanément la grille (cf. §6.5).
     5. Tri (`SortSelect`) : changer l’option met à jour instantanément la grille.
     6. Bouton “Réinitialiser la recherche” remet tout à zéro.

4. **Tester le fallback mock**

   - Couper le backend (ex. arrêter le serveur).
   - Taper “EDR” : bannière “Attention : Erreur serveur …” et produits mock filtrés (seulement ceux dont `name`, `description` ou `caracteristics` contient “EDR”).
   - Si aucun mock ne correspond, afficher “Aucun produit ne correspond à votre recherche.”

5. **Tester l’accessibilité**

   - Parcours clavier (Tab, Shift+Tab) : tous les éléments interactifs (cases à cocher, inputs, buttons, selects) doivent recevoir le focus.
   - `aria-label` sur les inputs, `role="alert"` pour les messages d’erreur, `role="status"` pour le loader.
   - Contraste des couleurs conforme (texte noir sur fond blanc, éléments de mise en évidence violet foncé, textes secondaires gris foncé).

6. **Tester la responsivité**

   - En desktop (>= 1024 px) : deux colonnes (filtres à gauche, contenu à droite, grille 3 colonnes).
   - En tablette (>= 640 px et < 1024 px) : filtres au-dessus, grille 2 colonnes.
   - En mobile (< 640 px) : filtres au-dessus, grille 1 colonne, champ in-page large.

---

## Explications détaillées et flux utilisateur

1. **Arrivée sur la page `/search`**

   - Le champ de recherche in-page reçoit le focus automatique.
   - Si `query === ""`, le titre affiche “Recherche” et un message centré invite à saisir un mot-clé.
   - Le panneau de filtres est visible immédiatement (en mobile, il est placé au-dessus du contenu principal).

2. **Saisie d’un mot-clé**

   - Chaque frappe met à jour `localInput`.
   - Après 300 ms sans nouvelle frappe :

     - `dispatch(setQuery(trimmed))` met à jour `query` dans Redux.
     - `dispatch(searchProducts({ … }))` appelle l’API (ou applique le fallback).

   - Le `useEffect` sur `query` dans `SearchBar.jsx` synchronise également l’input de la Navbar (si présent) avec la même valeur.

3. **Affichage des résultats**

   - Tant que `loading === true`, on affiche `<Loader />` centré (horizontale + verticale).
   - Quand `loading === false` :

     - Si `error` non nul : bannière jaune d’avertissement (“Attention : Erreur serveur …”) puis grille avec résultats mock (s’ils existent).
     - Si `searchResults.length === 0 && error === null` : `<EmptyState message="Aucun produit..." />`.
     - Sinon : la grille de produits (`ProductCard`) s’affiche (layout responsive 1-2-3 colonnes).

4. **Facettes et tri**

   - Chaque modification de facette (case à cocher, prix, disponibilité) met à jour les états locaux et déclenche une nouvelle exécution de `searchProducts` (via l’`useEffect`).
   - Le tri (`SortSelect`) fait de même en modifiant `sort`.
   - Le backend (ou le filtrage mock) doit gérer le paramètre `sort` pour trier correctement les résultats.

5. **Réinitialisation**

   - Le bouton “Réinitialiser la recherche” (à droite du titre) et le bouton “Réinitialiser tous les filtres” (en bas du panneau de filtres) appellent tous deux `handleResetAll()`.
   - Cette fonction effectue :

     - `dispatch(clearSearch())` → vide `query`, `searchResults`, `error`.
     - Remet toutes les facettes (`selectedCategoriesIds`, `selectedFeatures`, `minPrice`, `maxPrice`, `availableOnly`, `sort`) à leur état initial.
     - Vide `localInput` : l’`useEffect` réinitialise également `query` et vide la grille.

6. **Recherche depuis la Navbar**

   - En desktop, l’utilisateur peut taper directement dans `SearchBar.jsx`.
   - Debounce 300 ms :

     - `dispatch(setQuery(trimmed))`
     - `dispatch(searchProducts({ keyword: trimmed, …facettes par défaut… }))`
     - `navigate("/search")` si on n’est pas déjà sur `/search`.

   - Le champ in-page de `SearchPage.jsx` (via `useEffect([query])`) se synchronise sur la nouvelle valeur de `query`.
   - Ainsi, taper dans la Navbar produit le même effet que taper dans le champ in-page.

7. **Pagination**

   - Les paramètres `currentPage` et `pageSize` sont envoyés à `searchProducts`.
   - Il est possible d’ajouter ultérieurement un composant “Pagination” (nav de pages) qui mettra à jour `currentPage` dans le store, entraînant un nouvel appel `searchProducts`.

---

## Accessibilité et bonnes pratiques

1. **ARIA et rôles**

   - **Champ de recherche in-page** : `aria-label="Rechercher un produit ou service"`.
   - **SearchBar (Navbar)** : `aria-label="Champ de recherche de produit"`.
   - **Loader** : `role="status"` et `aria-label="Chargement des résultats"`.
   - **Bannière d’erreur** : `<div role="alert" aria-live="assertive">` indique une information importante.
   - **Overlay mobile (ancienne version)** : utilisait `role="dialog" aria-modal="true"` (supprimé, cf. §13).

2. **Gestion du focus**

   - **Champ in-page** reçoit le focus automatiquement (`inPageInputRef.current.focus()`) lors de l’arrivée sur `/search`.
   - **Titre `<h2>`** contient `tabIndex={-1}` pour permettre au lecteur d’écran de se positionner sur le titre lorsqu’il arrive sur la page.
   - Tous les éléments interactifs (inputs, checkboxes, buttons, selects) sont focusables.

3. **Contraste des couleurs**

   - Texte foncé sur fond clair (noir sur blanc, violet foncé sur blanc) pour une meilleure lisibilité.
   - La bannière d’erreur est en `text-yellow-600`, fond blanc.

4. **Responsive Design**

   - **Desktop** (>= 1024 px) :

     - Layout en deux colonnes : panneau de filtres à gauche (25 %), contenu principal à droite (75 %).
     - Grille de produits en 3 colonnes (`lg:grid-cols-3`).

   - **Tablette** (>= 640 px et < 1024 px) :

     - Panneau de filtres au-dessus du contenu principal (stacked), puis grille 2 colonnes (`sm:grid-cols-2`).

   - **Mobile** (< 640 px) :

     - Panneau de filtres au-dessus, puis champ in-page, puis contenu principal (stacked).
     - Grille de produits en 1 colonne (`grid-cols-1`).

5. **Debounce**

   - Limiter les appels API à un toutes les 300 ms lorsque l’utilisateur tape.

6. **Fallback mock**

   - Si le backend est indisponible, la fonction `searchProducts` applique un filtrage local à `MOCK_TOP_PRODUCTS`.
   - Seuls les produits simulés correspondant aux critères sont retournés (mot-clé, catégories, caractéristiques, prix, disponibilité).

---

## Mise à jour mobile : suppression du modal overlay (cf. update table)

### Ancien comportement

- **Mobile** : dès qu’on cliquait sur l’icône loupe dans la navbar, un composant `ModalOverlay` se chargeait, affichant un overlay sombre et invitant à taper dans la `SearchBar` intégrée dans le modal.
- L’utilisateur devait fermer la modale pour voir les résultats (puis naviguer vers `/search`).
- Composant `ModalOverlay` (non-documenté initialement) :

  ```jsx
  import PropTypes from "prop-types";
  import { useEffect, useRef } from "react";

  const ModalOverlay = ({ children, onClose }) => {
    const modalRef = useRef(null);

    // Ferme la modale sur Échap
    useEffect(() => {
      const handleKeyDown = (e) => {
        if (e.key === "Escape") {
          onClose();
        }
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }, [onClose]);

    // Focus automatique sur la modale
    useEffect(() => {
      if (modalRef.current) {
        modalRef.current.focus();
      }
    }, []);

    return (
      <div
        className="fixed inset-0 z-50 bg-black bg-opacity-50 flex items-center justify-center"
        onClick={onClose}
        aria-modal="true"
        role="dialog"
        tabIndex={-1}
        aria-label="Fenêtre modale"
      >
        <div
          className="bg-white rounded-xl shadow-lg p-6 w-full max-w-lg"
          onClick={(e) => e.stopPropagation()}
          ref={modalRef}
          tabIndex={0}
        >
          {children}
        </div>
      </div>
    );
  };

  ModalOverlay.propTypes = {
    children: PropTypes.node.isRequired,
    onClose: PropTypes.func.isRequired,
  };

  export default ModalOverlay;
  ```

### Nouveau comportement (cf. §8)

- **Mobile** : au clic sur l’icône loupe, on redirige directement vers `/search`.
- L’utilisateur voit immédiatement sur la page `/search` le **champ de recherche in-page** avec focus automatique.
- La logique de la recherche est identique, sans passage par une modale intermédiaire.
- **Pourquoi cette modification ?**

  - Conformité CDC : “la page de recherche doit être accessible directement”.
  - Simplicité d’implémentation et d’expérience utilisateur (pas de modal à fermer).
  - Consistance desktop/mobile (desktop utilise `SearchBar` dans la navbar, mobile redirige vers une page avec champ in-page).

---

## Conclusion

Cette documentation présente l’implémentation complète et professionnelle de la fonctionnalité **“Recherche”** :

1. **Slices Redux**

   - `searchSlice.js` : gestion du mot-clé, des états de chargement/erreur, fallback local, pagination, facettes, tri.
   - `categorySlice.js` : récupération des catégories (API + fallback).

2. **Composants de filtre**

   - `FilterCheckboxes.jsx`, `PriceSlider.jsx`, `AvailabilityToggle.jsx`, `SortSelect.jsx`.

3. **Page de recherche**

   - `SearchPage.jsx` : champ in-page, titre, tri, filtres, grille de résultats, gestion du loading, des erreurs, de l’empty state.

4. **Utilitaires d’interface**

   - `SearchBar.jsx` (navbar desktop), `EmptyState.jsx`, `Loader.jsx`.

5. **Navbar mobile**

   - Suppression du modal overlay (cf. §13) : la loupe mobile redirige simplement vers `/search`.

6. **Routeur**

   - Déclaration de la route `/search` dans `App.jsx`.

7. **Accessibilité**

   - ARIA, focus au chargement, contraste, éléments keyboard-friendly.

8. **Responsive Design**

   - Mise en page adaptable 1-2-3 colonnes, panneau de filtres et contenu principal adaptés selon la taille d’écran.

L’ensemble répond pleinement au **Cahier des Charges** et garantit une expérience utilisateur fluide, quel que soit l’appareil (desktop, mobile, tablette).
